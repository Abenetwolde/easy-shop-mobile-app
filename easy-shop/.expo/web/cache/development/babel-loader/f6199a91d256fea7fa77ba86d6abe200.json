{"ast":null,"code":"\n\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from \"./createResponderEvent\";\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from \"./ResponderEventTypes\";\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from \"./utils\";\nimport ResponderTouchHistoryStore from \"./ResponderTouchHistoryStore\";\n\nvar emptyObject = {};\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n\n  if (\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent);\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n      id = _currentResponder.id,\n      node = _currentResponder.node;\n    var _getResponderConfig = getResponderConfig(id),\n      onResponderStart = _getResponderConfig.onResponderStart,\n      onResponderMove = _getResponderConfig.onResponderMove,\n      onResponderEnd = _getResponderConfig.onResponderEnd,\n      onResponderRelease = _getResponderConfig.onResponderRelease,\n      onResponderTerminate = _getResponderConfig.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) ||\n      eventType === 'contextmenu' ||\n      eventType === 'blur' && eventTarget === window ||\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||\n      isScrollEvent && trackedTouchCount === 0 ||\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||\n      isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          onResponderEnd(responderEvent);\n        }\n      }\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated ||\n          onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n            shouldTerminate = false;\n          }\n        }\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n      nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath\n          };\n        }\n      }\n    };\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n        if (_result != null) {\n          return _result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n    currentId = _currentResponder2.id,\n    currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n    node = wantsResponder.node;\n  var _getResponderConfig2 = getResponderConfig(id),\n    onResponderGrant = _getResponderConfig2.onResponderGrant,\n    onResponderReject = _getResponderConfig2.onResponderReject;\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n    var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        onResponderTerminate(responderEvent);\n      }\n\n      if (onResponderGrant != null) {\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [\n'mousedown', 'mousemove', 'mouseup', 'dragstart',\n'touchstart', 'touchmove', 'touchend', 'touchcancel',\n'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n    id = _currentResponder3.id,\n    node = _currentResponder3.node;\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n      onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\nexport function getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"names":["canUseDOM","createResponderEvent","isCancelish","isEndish","isMoveish","isScroll","isSelectionChange","isStartish","getLowestCommonAncestor","getResponderPaths","hasTargetTouches","hasValidSelection","isPrimaryPointerDown","setResponderId","ResponderTouchHistoryStore","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","isTerminateEvent","window","contains","relatedTarget","isReleaseEvent","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","dispatchConfig","registrationName","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","__reactResponderSystemActive","addEventListener","forEach","document","addNode","set","removeNode","terminateResponder","has","delete","_currentResponder3","_getResponderConfig4","event","getResponderNode"],"sources":["C:/Users/AfroMiNA/OneDrive/Desktop/ecom/mern-stack-ecommerce/easy-shop/node_modules/react-native-web/dist/hooks/useResponderEvents/ResponderSystem.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from './createResponderEvent';\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';\nimport ResponderTouchHistoryStore from './ResponderTouchHistoryStore';\n/* ------------ TYPES ------------ */\n\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n        if (onResponderMove != null) {\n          onResponderMove(responderEvent);\n        }\n      } else {\n        var isTerminateEvent = isCancelish(eventType) || // native context menu\n        eventType === 'contextmenu' || // window blur\n        eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n        isSelectionChangeEvent && hasValidSelection(domEvent);\n        var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches); // End\n\n        if (isEndEvent) {\n          if (onResponderEnd != null) {\n            onResponderEnd(responderEvent);\n          }\n        } // Release\n\n\n        if (isReleaseEvent) {\n          if (onResponderRelease != null) {\n            onResponderRelease(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n        } // Terminate\n\n\n        if (isTerminateEvent) {\n          var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n            if (wasNegotiated || // Only call this function is it wasn't already called during negotiation.\n            onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n\n          if (shouldTerminate) {\n            if (onResponderTerminate != null) {\n              onResponderTerminate(responderEvent);\n            }\n\n            changeCurrentResponder(emptyResponder);\n            isEmulatingMouseEvents = false;\n            trackedTouchCount = 0;\n          }\n        }\n      }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n      var _getResponderConfig3 = getResponderConfig(currentId),\n          onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n          onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n      var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n\n      if (allowTransfer) {\n        // Terminate existing responder\n        if (onResponderTerminate != null) {\n          responderEvent.currentTarget = currentNode;\n          onResponderTerminate(responderEvent);\n        } // Grant next responder\n\n\n        if (onResponderGrant != null) {\n          onResponderGrant(responderEvent);\n        }\n\n        changeCurrentResponder(wantsResponder);\n      } else {\n        // Reject responder request\n        if (onResponderReject != null) {\n          onResponderReject(responderEvent);\n        }\n      }\n    }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\nexport function getResponderNode() {\n  return currentResponder.node;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}